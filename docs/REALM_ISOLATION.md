# ğŸ” Realm Isolation Architecture

## Overview

Each realm generated by the Realm Generator is **completely isolated** from The Awa Network and sibling realms. This prevents context bleed and ensures clean, independent development.

## Isolation Mechanisms

### 1. Separate DevContainers âœ…

Each realm has its own `.devcontainer/`:

```
cards_realm/
â”œâ”€â”€ .devcontainer/
â”‚   â”œâ”€â”€ devcontainer.json     â† Independent container config
â”‚   â”œâ”€â”€ Dockerfile            â† Isolated Python env
â”‚   â””â”€â”€ post_create.sh        â† Realm-specific setup
â””â”€â”€ ...

translator_realm/
â”œâ”€â”€ .devcontainer/            â† DIFFERENT container
â”‚   â”œâ”€â”€ devcontainer.json
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ post_create.sh
â””â”€â”€ ...

The_Awa_Network/
â”œâ”€â”€ .devcontainer/            â† Main container (separate)
â””â”€â”€ ...
```

**Result:** Each realm runs in its own Docker container with isolated Python environment.

### 2. Realm-Aware Kaitiaki

Kaitiaki templates include strict isolation rules:

```yaml
isolation:
  level: "strict"
  aware_of:
    - own_realm_files
    - own_realm_config
    - own_realm_state
    - local_te_po_proxy

  NOT_aware_of:
    - The_Awa_Network_context
    - sibling_realm_data
    - main_Te_Po_state

  access_control:
    allow_parent_traversal: false
    allow_workspaces_access: false
    allow_sibling_realms: false
    allow_main_awa_network: false
```

**Result:** Kaitiaki at runtime knows its boundaries and can't access parent folders.

### 3. Isolated File Systems

Each realm sees only itself:

```
realm_root/                           â† Realm's view of filesystem
â”œâ”€â”€ kaitiaki/                         âœ… Accessible
â”œâ”€â”€ mauri/                            âœ… Accessible
â”œâ”€â”€ te_po_proxy/                      âœ… Accessible
â”œâ”€â”€ te_ao/                            âœ… Accessible
â”œâ”€â”€ .env                              âœ… Realm-specific secrets
â”‚
â”œâ”€â”€ ../                               âŒ FORBIDDEN
â”œâ”€â”€ /workspaces/                      âŒ FORBIDDEN
â”œâ”€â”€ /home/                            âŒ FORBIDDEN
â””â”€â”€ /The_Awa_Network/                 âŒ FORBIDDEN
```

### 4. Separate Python Environments

Each realm gets:
- âœ… Own Python 3.12 installation
- âœ… Own `requirements.txt` (realm-specific)
- âœ… Own virtual environment (if used)
- âŒ NO access to parent venv

```bash
# Realm devcontainer
/usr/bin/python3                       # Independent Python

# Main Awa Network devcontainer
/usr/bin/python3                       # Different container instance
```

### 5. Separate VS Code Settings

Each realm has `.vscode/settings.json` with realm-specific config:

```json
{
  "python.analysis.extraPaths": ["./mauri", "./kaitiaki"],
  "[python]": { "editor.formatOnSave": true },
  "search.exclude": { "**/node_modules": true }
}
```

**Result:** VS Code uses realm-local settings (not parent settings).

## Backend Proxy Pattern

Realms DO NOT directly access main Te PÅ. Instead:

```
Realm's Kaitiaki
    â†“ (talks to local proxy)
Realm's te_po_proxy/
    â†“ (proxies to)
Main Te PÅ (read-only via proxy)
    â†“
Supabase + Vectors (shared)
```

**Benefits:**
- âœ… Realm can't modify main system data
- âœ… Clear API boundary
- âœ… Easy to test/mock
- âœ… No context bleed

**Configuration:**

```yaml
backend:
  proxy:
    url: "http://localhost:8001"
    type: "te_po_proxy"
    description: "Local realm backend"

  forbidden_targets:
    - "https://main-te-po.example.com"
    - "main_te_po"
    - "te_po"
```

## Isolation Enforcement

### Runtime Checks

Realm's Kaitiaki should check:

```python
# In realm's kaitiaki/agent/agent.py

import os
from pathlib import Path

class IsolatedKaitiaki:
    def __init__(self):
        self.realm_root = Path.cwd()
        self._check_isolation()

    def _check_isolation(self):
        """Ensure realm is truly isolated."""
        forbidden = [
            "..",
            "/workspaces/The_Awa_Network",
            "/home/",
            "/workspace/"
        ]

        for path in forbidden:
            expanded = Path(path).resolve()
            if expanded in self.realm_root.parents:
                raise SecurityError(f"Realm can't access {path}")

    def read_realm_file(self, rel_path: str):
        """Read only from realm directory."""
        file_path = (self.realm_root / rel_path).resolve()

        # Ensure file is inside realm
        if not str(file_path).startswith(str(self.realm_root)):
            raise SecurityError(f"Access denied: {rel_path}")

        return file_path.read_text()
```

### Directory Structure Enforcement

Generated realm structure prevents accidents:

```
cards_realm/                          â† Open realm
â”œâ”€â”€ .devcontainer/                    â† Own container
â”œâ”€â”€ .vscode/                          â† Own IDE settings
â”œâ”€â”€ .env                              â† Own secrets
â”œâ”€â”€ requirements.txt                  â† Own dependencies
â”œâ”€â”€ kaitiaki/
â”‚   â””â”€â”€ katu/                         â† Only aware of this agent
â”œâ”€â”€ mauri/
â”‚   â”œâ”€â”€ context.md                    â† Only this realm's context
â”‚   â”œâ”€â”€ global_env.json               â† Only this realm's env
â”‚   â””â”€â”€ kaitiaki_templates/
â”‚       â””â”€â”€ katu.yaml                 â† Isolation rules in YAML
â”œâ”€â”€ te_po_proxy/                      â† Local backend (safe)
â”œâ”€â”€ te_ao/                            â† Local frontend
â””â”€â”€ te_hau/                           â† Local CLI
```

## What Gets Isolated

### âœ… Isolated (Per Realm)

| Item | Details |
|------|---------|
| Kaitiaki agent | Each realm's agent unaware of others |
| Python environment | Separate venv/container per realm |
| Configuration | Separate `.env`, `config/`, `mauri/` |
| Frontend | Separate `te_ao/` builds |
| Backend proxy | Local `te_po_proxy/` (no shared instance) |
| Logs | Stored in `realm/logs/` not shared |
| State files | `realm/mauri/state/` not shared |
| Dependencies | Each realm's `requirements.txt` |
| VS Code settings | Realm-specific `.vscode/` |

### âŒ NOT Isolated (Shared)

| Item | Details |
|------|---------|
| Main Te PÅ backend | Read-only via proxy |
| Vector database | Shared Supabase pgvector |
| Secret keys | Retrieved per-realm via `.env` |
| Documentation | Shared in `/docs/` |

## Workflow: Working Across Realms

### Scenario: Edit main The_Awa_Network

1. Open devcontainer in VS Code
2. `devcontainer.json` opens The_Awa_Network container
3. Edit `/te_hau/`, `/te_po/`, etc.
4. Changes isolated to main project

### Scenario: Edit cards_realm

1. Open `cards_realm/` as folder in new VS Code window
2. DevContainer opens cards_realm's isolated container
3. Edit `cards_realm/te_po_proxy/`, `cards_realm/kaitiaki/`, etc.
4. Changes isolated to cards_realm only
5. âœ… Main The_Awa_Network untouched

### Scenario: Use Multi-Folder Workspace (Optional)

```json
// Titirauwakawa.code-workspace
{
  "folders": [
    { "name": "ğŸ”ï¸ The Awa Network", "path": "The_Awa_Network" },
    { "name": "ğŸƒ Cards Realm", "path": "cards_realm" }
  ]
}
```

Each folder opens its own devcontainer (if configured).

## Preventing Context Bleed

### Anti-Pattern âŒ

```python
# BAD: Accessing parent realm
import sys
sys.path.insert(0, "../../The_Awa_Network")
from te_po import SomethingFromMain  # âŒ Context bleed!
```

### Correct Pattern âœ…

```python
# GOOD: Use proxy pattern
import httpx

async def query_main_backend(query: str):
    async with httpx.AsyncClient() as client:
        # Talk only to local proxy
        response = await client.post(
            "http://localhost:8001/query",  # Local proxy
            json={"query": query}
        )
        return response.json()
```

## Testing Isolation

### Verify File Access

```bash
# Inside cards_realm devcontainer
cd cards_realm

# This should work
python -c "import mauri; print('âœ… Realm files accessible')"

# This should FAIL
cd ..
python -c "import The_Awa_Network.te_po"  # âŒ Should error
```

### Verify Environment

```bash
# Inside cards_realm
echo $PYTHONPATH                       # Should NOT include parent
echo $PATH                             # Should NOT include parent bins
which python                           # Should be container's python
```

### Verify DevContainer

```bash
# Inside cards_realm container
ls ..                                  # Should show cards_realm only (from container view)
pwd                                    # Should be /workspaces/
ls -la /workspaces/The_Awa_Network     # Should NOT exist (from realm perspective)
```

## Documentation Location

Each realm gets its own docs:

```
cards_realm/
â”œâ”€â”€ README.md                         â† Realm-specific
â”œâ”€â”€ docs/                             â† Realm-specific docs
â”‚   â”œâ”€â”€ SETUP.md
â”‚   â”œâ”€â”€ AGENTS.md
â”‚   â””â”€â”€ API.md
â””â”€â”€ STRUCTURE.md
```

These are independent of main docs at `/The_Awa_Network/docs/`.

## Debugging Isolation Issues

### If realm can access parent:

1. Check `.devcontainer/Dockerfile` â€” should NOT mount parent
2. Check `.env` â€” should NOT reference parent paths
3. Check `kaitiaki_templates/*.yaml` â€” should have isolation rules
4. Check Python `sys.path` â€” should NOT include parent

### If context is leaking:

1. Check imports â€” avoid `import ..The_Awa_Network`
2. Check API calls â€” ensure using `http://localhost:8001` not main URL
3. Check configs â€” ensure using `./config/` not parent config
4. Check environment â€” ensure `.env` is realm-local not inherited

---

**Key Principle:** A realm should work identically whether The_Awa_Network exists or not. It is completely self-contained.
